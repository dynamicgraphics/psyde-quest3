<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Psyde Quest</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* CSS styles remain largely the same, with the key change to the mini-map background */
        body, html { /* ... */ }
        #game-container { /* ... */ }
        .screen { /* ... */ }
        #start-screen { /* ... */ }
        #game-screen { /* ... */ }
        h1, p, button { /* ... */ }

        #mini-map-container {
            position: absolute; top: 20px; left: 20px;
            width: 150px; height: 150px;
            background-color: rgba(0,0,0,0.8);
            border-radius: 50%;
            z-index: 100;
            /* CORRECTED: Ultra-simple SVG for a clean circular border */
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="150" height="150"><circle cx="75" cy="75" r="73" fill="none" stroke="white" stroke-width="4"/></svg>');
            image-rendering: pixelated;
            transition: all 0.5s ease-in-out;
        }
        
        #mini-map-container.shrunk { /* ... */ }
        #player-arrow { /* ... */ }
        #beacon-dot { /* ... */ }
        #ring-container { /* ... */ }
        #ring-container.active { /* ... */ }
        @keyframes pulse { /* ... */ }
        #instruction-text { /* ... */ }
        #scan-button { /* ... */ }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="start-screen" class="screen">
            <h1>Psyde Quest</h1>
            <p id="start-prompt">An adventure awaits. Allow permissions to begin your quest.</p>
            <button id="start-button">Begin</button>
            <p style="font-size: 0.6em; margin-top: 20px;">(This game does not collect or store any personal data)</p>
        </div>
        <div id="game-screen" class="screen">
            <div id="mini-map-container">
                <div id="player-arrow"></div>
                <div id="beacon-dot"></div>
            </div>
            <div id="ring-container"></div>
            <p id="instruction-text">Initializing...</p>
            <button id="scan-button">Scan for Beacon</button>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const scanButton = document.getElementById('scan-button');
        const miniMap = document.getElementById('mini-map-container');
        // ... (other elements)

        // --- Game State & Beacons ---
        const BEACON_UUID = "8ec76ea3-6668-48da-9866-75be8d83f82d";
        const targetBeacon = { lat: 32.5362, lon: -97.3239 }; 
        const ACTIVATION_DISTANCE_METERS = 10; 
        let previousDistance = Infinity;
        let lastInstructionUpdateTime = 0; // For text cooldown

        // --- Arrow Smoothing Variables ---
        let currentArrowAngle = 0;
        let targetArrowAngle = 0;
        
        // --- Initial Load & Listeners ---
        window.addEventListener('load', checkPermissionsOnLoad);
        startButton.addEventListener('click', requestPermissionsAndStart);
        scanButton.addEventListener('click', scanForBeacon);

        // --- Core Functions ---
        async function checkPermissionsOnLoad() { /* ... */ }
        async function requestPermissionsAndStart() { /* ... */ }

        function startGame() {
            startScreen.style.display = 'none';
            gameScreen.style.display = 'block';
            updateInstructionText("Follow the red dot on your map.");
            window.addEventListener('deviceorientation', handleOrientation);
            navigator.geolocation.watchPosition(handlePositionUpdate);
            
            // Start the arrow smoothing animation loop
            requestAnimationFrame(updateArrowRotation);
        }

        function updateInstructionText(message) {
            const now = Date.now();
            // Cooldown logic: only update text every 2 seconds to prevent spam
            if (now - lastInstructionUpdateTime < 2000 && message.includes('warmer') || message.includes('colder')) {
                return;
            }
            instructionText.textContent = message;
            lastInstructionUpdateTime = now;
        }
        
        // --- Arrow and Position Handling ---
        function handleOrientation(event) {
            if (event.alpha) {
                // We just update the target angle. The animation loop handles the rest.
                targetArrowAngle = event.alpha;
            }
        }
        
        // NEW: Arrow smoothing animation loop
        function updateArrowRotation() {
            currentArrowAngle = lerpAngle(currentArrowAngle, targetArrowAngle, 0.1);
            playerArrow.style.transform = `translate(-50%, -60%) rotate(${currentArrowAngle}deg)`;
            requestAnimationFrame(updateArrowRotation); // Continue the loop
        }

        function handlePositionUpdate(position) {
            const playerLat = position.coords.latitude;
            const playerLon = position.coords.longitude;
            const distance = getDistance(playerLat, playerLon, targetBeacon.lat, targetBeacon.lon);
            
            if (distance <= ACTIVATION_DISTANCE_METERS) {
                ringContainer.classList.add('active');
                miniMap.classList.add('shrunk');
                scanButton.style.display = 'block';
                updateInstructionText("You're close! Press SCAN!");
            } else {
                ringContainer.classList.remove('active');
                miniMap.classList.remove('shrunk');
                scanButton.style.display = 'none';
                
                if (previousDistance - distance > 2) {
                    updateInstructionText("You're getting warmer...");
                } else if (distance - previousDistance > 2) {
                    updateInstructionText("Getting colder... Turn back!");
                }
            }
            previousDistance = distance;
            updateBeaconDot(playerLat, playerLon, targetBeacon.lat, targetBeacon.lon);
        }

        // --- Web Bluetooth Scan Function ---
        async function scanForBeacon() {
            if (!navigator.bluetooth) {
                alert("Web Bluetooth is not available on this device! Please use Chrome on Android or a computer.");
                return;
            }
            
            try {
                updateInstructionText("Searching for beacon signal...");
                
                // CORRECTED: Scanning by name is more reliable for iBeacons
                const device = await navigator.bluetooth.requestDevice({
                    filters: [{ namePrefix: 'ESP32_iBeacon' }],
                    optionalServices: [BEACON_UUID] // Still request the service to interact with it later
                });

                updateInstructionText("Beacon Found! Quest Complete!");
                navigator.vibrate(200);
                ringContainer.style.borderColor = '#00FF00';
                scanButton.style.display = 'none';

            } catch (error) {
                console.error("Scan failed:", error);
                // The most common "error" is the user pressing cancel.
                updateInstructionText("Scan failed or canceled. Try again!");
            }
        }
        
        // --- Helper Functions ---
        function updateBeaconDot(playerLat, playerLon, beaconLat, beaconLon) { /* ... */ }
        function getDistance(lat1, lon1, lat2, lon2) { /* ... */ }
        function getBearing(lat1, lon1, lat2, lon2) { /* ... */ }

        // NEW: Helper function for smooth angular interpolation (handles 359->1 degree wrap)
        function lerpAngle(start, end, amount) {
            let difference = Math.abs(end - start);
            if (difference > 180) {
                if (end > start) {
                    start += 360;
                } else {
                    end += 360;
                }
            }
            let value = (start + ((end - start) * amount));
            return value % 360;
        }

    </script>
</body>
</html>
