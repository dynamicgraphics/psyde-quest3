<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Psyde Quest</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* --- General Styling --- */
        body, html {
            background-color: #000;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            text-align: center;
        }

        /* --- Game Container --- */
        #game-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
            width: 100%;
            background: #222 url('https://res.cloudinary.com/dvf40x79k/image/upload/v1708645009/dungeon_tile_bg_y3j86m.png') repeat;
            position: relative;
        }
        
        /* --- Screen Styling --- */
        .screen {
            display: none; /* All screens hidden by default */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 90%;
            max-width: 400px;
            background-color: rgba(0,0,0,0.7); /* Dark overlay for readability */
            padding: 20px;
            border: 4px solid #fff;
            box-shadow: 0 0 15px rgba(255,255,255,0.5);
            z-index: 10; /* Make sure screens are on top */
        }
        
        #start-screen {
            display: flex; 
        }

        #game-screen {
            background: none;
            border: none;
            box-shadow: none;
        }
        
        h1 {
            font-size: 2em;
            color: #FFFF00;
            text-shadow: 3px 3px #AA5D00;
            margin-bottom: 20px;
        }

        p {
            font-size: 0.8em;
            line-height: 1.5;
            margin: 10px 0;
        }
        
        button {
            background-color: #555;
            color: #fff;
            border: 3px solid #fff;
            padding: 15px 25px;
            font-family: 'Press Start 2P', cursive;
            cursor: pointer;
            box-shadow: 4px 4px #222;
            margin-top: 20px;
        }

        /* --- Mini-Map Styling --- */
        #mini-map-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            border: 3px solid #fff;
            border-radius: 50%; /* Circular map */
            background-color: rgba(0,0,0,0.8);
            box-shadow: 0 0 10px #000;
            z-index: 100;
        }
        
        #player-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 15px solid #00FF00; /* Green player arrow */
            transform: translate(-50%, -50%);
            transition: transform 0.2s linear; /* Smooth rotation */
        }
        
        #beacon-dot {
            position: absolute;
            width: 15px;
            height: 15px;
            background-color: #FF0000; /* Red beacon dot */
            border-radius: 50%;
            border: 2px solid #fff;
            /* Position will be set by JavaScript */
        }

        /* --- Proximity Ring Styling --- */
        #ring-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 250px;
            height: 250px;
            border: 5px solid #555; /* Dormant color */
            border-radius: 50%;
            transition: all 0.5s ease;
        }
        
        #ring-container.active {
            border-color: #FFFF00; /* Active yellow color */
            box-shadow: 0 0 20px #FFFF00;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(0.95); box-shadow: 0 0 0 0 rgba(255, 255, 0, 0.7); }
            70% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 10px 20px rgba(255, 255, 0, 0); }
            100% { transform: translate(-50%, -50%) scale(0.95); box-shadow: 0 0 0 0 rgba(255, 255, 0, 0); }
        }

    </style>
</head>
<body>

    <div id="game-container">

        <div id="start-screen" class="screen">
            <h1>Psyde Quest</h1>
            <p>An adventure awaits. Allow permissions to begin your quest.</p>
            <button id="start-button">Begin</button>
        </div>

        <div id="game-screen" class="screen">
            <div id="mini-map-container">
                <div id="player-arrow"></div>
                <div id="beacon-dot"></div>
            </div>
            <div id="ring-container"></div>
        </div>

    </div>

    <script>
        // --- DOM Elements ---
        const startScreen = document.getElementById('start-screen');
        const gameScreen = document.getElementById('game-screen');
        const startButton = document.getElementById('start-button');
        const playerArrow = document.getElementById('player-arrow');
        const beaconDot = document.getElementById('beacon-dot');
        const ringContainer = document.getElementById('ring-container');

        // --- Game State & Beacons ---
        // Placeholder for the first beacon's location (e.g., somewhere in Burleson, TX)
        // We will make this a dynamic list later.
        const targetBeacon = { lat: 32.5362, lon: -97.3239 }; 
        const ACTIVATION_DISTANCE_METERS = 10; // 10 meters = ~33 feet

        // --- Event Listener ---
        startButton.addEventListener('click', requestPermissionsAndStart);

        // --- Core Functions ---
        async function requestPermissionsAndStart() {
            // Requesting motion/orientation sensors is crucial for the mini-map arrow
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const permissionState = await DeviceOrientationEvent.requestPermission();
                    if (permissionState !== 'granted') {
                        alert("Compass access is required for the mini-map. Please refresh and grant permission.");
                        return;
                    }
                } catch (error) {
                    console.warn("Compass permission request failed or not needed.", error);
                }
            }
            // GPS Permission
            if (!('geolocation' in navigator)) {
                alert("Geolocation is not supported.");
                return;
            }
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    console.log("GPS permission granted.");
                    startGame();
                },
                (error) => {
                    alert("GPS access is required. Please refresh and grant permission.");
                }
            );
        }

        function startGame() {
            startScreen.style.display = 'none';
            gameScreen.style.display = 'block'; // Use 'block' since it's not a flex container anymore
            
            // Start listening for device orientation (compass)
            window.addEventListener('deviceorientation', handleOrientation);
            
            // Start watching for GPS position changes
            navigator.geolocation.watchPosition(handlePositionUpdate);
        }

        function handleOrientation(event) {
            // event.alpha is the compass direction
            if (event.alpha) {
                playerArrow.style.transform = `translate(-50%, -50%) rotate(${event.alpha}deg)`;
            }
        }

        function handlePositionUpdate(position) {
            const playerLat = position.coords.latitude;
            const playerLon = position.coords.longitude;

            const distance = getDistance(playerLat, playerLon, targetBeacon.lat, targetBeacon.lon);
            
            // Activate or deactivate the ring based on distance
            if (distance <= ACTIVATION_DISTANCE_METERS) {
                ringContainer.classList.add('active');
            } else {
                ringContainer.classList.remove('active');
            }
            
            // Update the mini-map beacon dot
            updateBeaconDot(playerLat, playerLon, targetBeacon.lat, targetBeacon.lon);
        }
        
        function updateBeaconDot(playerLat, playerLon, beaconLat, beaconLon) {
            const bearing = getBearing(playerLat, playerLon, beaconLat, beaconLon);
            
            // Convert bearing to position on the edge of the circular mini-map
            // 0 deg (North) should be top, 90 (East) right, etc.
            const angle = bearing * (Math.PI / 180); // to radians
            const mapRadius = 50; // 50px radius (half of 120px width, minus padding)
            
            const x = mapRadius * Math.sin(angle);
            const y = -mapRadius * Math.cos(angle);
            
            // Position the dot from the center of the map
            beaconDot.style.left = `calc(50% + ${x}px)`;
            beaconDot.style.top = `calc(50% + ${y}px)`;
        }

        // --- Helper Functions for GPS calculations ---
        function getDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // metres
            const φ1 = lat1 * Math.PI/180;
            const φ2 = lat2 * Math.PI/180;
            const Δφ = (lat2-lat1) * Math.PI/180;
            const Δλ = (lon2-lon1) * Math.PI/180;

            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c; // in metres
        }
        
        function getBearing(lat1, lon1, lat2, lon2){
             const φ1 = lat1 * Math.PI/180;
             const φ2 = lat2 * Math.PI/180;
             const λ1 = lon1 * Math.PI/180;
             const λ2 = lon2 * Math.PI/180;
             
             const y = Math.sin(λ2-λ1) * Math.cos(φ2);
             const x = Math.cos(φ1)*Math.sin(φ2) -
                       Math.sin(φ1)*Math.cos(φ2)*Math.cos(λ2-λ1);
             const θ = Math.atan2(y, x);
             return (θ*180/Math.PI + 360) % 360; // in degrees
        }

    </script>
</body>
</html>
